/**
 * Death Detection Service
 * Analyzes repository commit history to determine if a repository is "dead"
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { getLogger } from '../utils/logger';
import { CodeCryptError } from '../utils/errors';
import { getCommitHistory } from './github';

const logger = getLogger();

/**
 * Result of death detection analysis
 */
export interface DeathAnalysis {
  /** Whether the repository is classified as dead */
  isDead: boolean;
  /** Date of the last commit */
  lastCommitDate: Date;
  /** Days since the last commit */
  daysSinceLastCommit: number;
  /** Cause of death description */
  causeOfDeath: string;
  /** Total number of commits analyzed */
  totalCommits: number;
}

/**
 * Threshold for classifying a repository as dead (in days)
 * 2 years = 730 days
 */
const DEATH_THRESHOLD_DAYS = 730;

/**
 * Analyze commit history to determine if repository is dead
 * A repository is considered "dead" if the last commit is older than 2 years
 */
export async function analyzeRepositoryDeath(repoPath: string): Promise<DeathAnalysis> {
  logger.info('Starting death detection analysis');
  
  try {
    // Fetch commit history
    const commits = await getCommitHistory(repoPath, 100);
    
    if (commits.length === 0) {
      throw new CodeCryptError(
        'Repository has no commits',
        'NO_COMMITS'
      );
    }
    
    // Get the most recent commit
    const lastCommit = commits[0];
    const lastCommitDate = new Date(lastCommit.date);
    const now = new Date();
    
    // Calculate days since last commit
    const daysSinceLastCommit = Math.floor(
      (now.getTime() - lastCommitDate.getTime()) / (1000 * 60 * 60 * 24)
    );
    
    // Determine if repository is dead
    const isDead = daysSinceLastCommit > DEATH_THRESHOLD_DAYS;
    
    // Determine cause of death
    let causeOfDeath: string;
    if (isDead) {
      const yearsSinceLastCommit = (daysSinceLastCommit / 365).toFixed(1);
      causeOfDeath = `Lack of recent activity (${yearsSinceLastCommit} years since last commit)`;
    } else {
      causeOfDeath = 'Repository is still active';
    }
    
    const analysis: DeathAnalysis = {
      isDead,
      lastCommitDate,
      daysSinceLastCommit,
      causeOfDeath,
      totalCommits: commits.length
    };
    
    logger.info(`Death analysis complete: isDead=${isDead}, daysSince=${daysSinceLastCommit}`);
    
    return analysis;
    
  } catch (error: any) {
    if (error instanceof CodeCryptError) {
      throw error;
    }
    throw new CodeCryptError(
      `Failed to analyze repository death: ${error.message}`,
      'DEATH_ANALYSIS_ERROR'
    );
  }
}

/**
 * Generate a Death Certificate in Markdown format
 * Documents the repository's death with last commit date and cause
 */
export async function generateDeathCertificate(
  repoPath: string,
  repoName: string,
  analysis: DeathAnalysis
): Promise<string> {
  logger.info('Generating death certificate');
  
  try {
    const certificate = `# ðŸª¦ Death Certificate

## Repository: ${repoName}

---

### Time of Death
**${analysis.lastCommitDate.toISOString().split('T')[0]}**  
*(${analysis.daysSinceLastCommit} days ago)*

### Cause of Death
${analysis.causeOfDeath}

### Vital Statistics
- **Total Commits Analyzed:** ${analysis.totalCommits}
- **Days Since Last Activity:** ${analysis.daysSinceLastCommit}
- **Classification:** ${analysis.isDead ? 'ðŸ’€ DEAD' : 'âœ… ALIVE'}

---

### Prognosis
${analysis.isDead 
  ? 'ðŸ§Ÿ This repository is a candidate for resurrection. CodeCrypt can attempt to modernize dependencies and restore functionality.'
  : 'âœ¨ This repository shows recent activity and may not require resurrection.'}

---

*Generated by CodeCrypt on ${new Date().toISOString().split('T')[0]}*
`;

    // Write certificate to the repository workspace
    const certificatePath = path.join(repoPath, 'death_certificate.md');
    await fs.writeFile(certificatePath, certificate, 'utf-8');
    
    logger.info(`Death certificate written to: ${certificatePath}`);
    
    return certificatePath;
    
  } catch (error: any) {
    throw new CodeCryptError(
      `Failed to generate death certificate: ${error.message}`,
      'CERTIFICATE_GENERATION_ERROR'
    );
  }
}
